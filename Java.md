# final 关键词
final指的是引用的不可变性，即只能指向初始化的那个对象，而不关心对象的内容变化，因此，***final修饰的变量必须被初始化***。
## final方法
子类不能重写final方法，但是可以使用。
## final参数
用来表示参数在函数体内不允许被修改
## final类
final类不能被继承，所有方法不能重写。但不意味着final类内部的成员变量不可修改。
# volatile
volatile是一个类型修饰符，用于修饰被不同线程访问和修改的变量。系统每次都直接从内存中获取volatile变量，而不是利用缓存。   
volatile不保证原子性。
## 两大特性
1. volatile变量的更新对所有线程可见。
2. 禁止指令重排序   
当程序执行到volatile变量的读或写时，在其前面的操作肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；
在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。
## 使用场景
1. 对变量的写操作不依赖于当前值。
2. 该变量没有包含在具有其他变量的不变式中。   
实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。
## 为什么不保证原子性
比如自增操作，自增分为三步骤：读取变量的原始值、+1操作、写入主存，也就是说，这三个子操作可能会割开执行：   
假如volatile修饰的变量x原本为10，现线程A和B同时进行x++   
线程A对变量进行自增，取出变量，阻塞   
线程B对变量进行自增，取出变量，由于线程A仅仅取出变量，没有对变量进行操作，因此不会造成线程B中缓存变量x的缓存行无效，进行x++后x变为11，写入内存   
线程A因为已经读取出来，已经过了取变量这一步，此时会直接进行x++，x为11，写入内存
## 底层原理
### happen-before
happen-before原则保证了程序的“有序性”，它规定如果两个操作的执行顺序无法从happens-before原则中推到出来，那么他们就不能保证有序性，可以随意进行重排序。其定义如下：   
1. 同一个线程中的，前面的操作 happen-before 后续的操作。（即单线程内按代码顺序执行。但是，在不影响在单线程环境执行结果的前提下，编译器和处理器可以进行重排序，这是合法的。换句话说，这一是规则无法保证编译重排和指令重排）。
2. 监视器上的解锁操作 happen-before 其后续的加锁操作。（Synchronized 规则）
3. 对volatile变量的写操作 happen-before 后续的读操作。（volatile 规则）
4. 线程的start() 方法 happen-before 该线程所有的后续操作。（线程启动规则）
5. 线程所有的操作 happen-before 其他线程在该线程上调用 join 返回成功后的操作。
6. 如果 a happen-before b，b happen-before c，则a happen-before c（传递性）。
### 内存屏障（Meomory Barrier）
内存屏障又称内存栅栏，是一个CPU指令，有两个作用：
1. 保证特定操作的执行顺序；
2. 保证某些变量的内存可见性（利用该特性实现volatile的内存可见性）
由于编译器和处理器都能执行指令重排优化。如果在指令间插入一条内存屏障，则会告诉编译器和处理器，不管什么指令都不能和这条内存屏障指令重排序。也就是说通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化。内存屏障的另一个作用是强制刷出CPU的缓存数据，因此CPU上的线程都能读取到数据的最新版本。
#### volatile写操作
会在写操作后加入一条store屏障指令，将工作内存中的共享变量值刷新回主存。
#### volatile读操作
会在读操作前加入一条load屏障指令，从主存中读取共享变量。

### volatile实现原理
计算机在运行程序时，每条指令都是在CPU中执行的，在执行过程中势必会涉及到数据的读写。我们知道程序运行的数据是存储在主存中，这时就会有一个问题，读写主存中的数据没有CPU中执行指令的速度快，如果任何的交互都需要与主存打交道则会大大影响效率，所以就有了CPU高速缓存。CPU高速缓存为某个CPU独有，只与在该CPU运行的线程有关。

有了CPU高速缓存虽然解决了效率问题，但是它会带来一个新的问题：数据一致性。在程序运行中，会将运行所需要的数据复制一份到CPU高速缓存中，在进行运算时CPU不再也主存打交道，而是直接从高速缓存中读写数据，只有当运行结束后才会将数据刷新到主存中。

有volatile修饰的共享变量进行写操作的时候会多出Lock前缀的指令，该指令在多核处理器下会引发两件事情。
* 将当前处理器缓存行数据刷写到系统主内存。
* 这个刷写回主内存的操作会使其他CPU缓存的该共享变量内存地址的数据无效。
这样就保证了多个处理器的缓存是一致的，对应的处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器缓存行设置无效状态，当处理器对这个数据进行修改操作的时候会重新从主内存中把数据读取到缓存里。


# wait() notify() notifyAll() sleep() yeild() join()
1. wait和notify用于多线程协调运行，在synchronized内部可以调用wait()使线程进入等待状态；
2. 必须在已获得的锁对象上调用wait()方法；
3. 在synchronized内部可以调用notify()或notifyAll()唤醒其他等待线程；
4. 必须在已获得的锁对象上调用notify()或notifyAll()方法；
5. 已唤醒的线程还需要重新获得锁后才能继续执行;
6. 使用notifyAll()将唤醒所有当前正在this锁等待的线程，而notify()只会唤醒其中一个（具体哪个依赖操作系统，有一定的随机性）。通常来说，notifyAll()更安全。有些时候，如果我们的代码逻辑考虑不周，用notify()会导致只唤醒了一个线程，而其他线程可能永远等待下去醒不过来了。
7. sleep()方法是Thread类的静态方法，而wait()是Object类的方法，用于线程间通信。sleep()不释放锁，到时间自动恢复执行。
8. 调用yield()方法的线程告诉虚拟机它乐意让其他线程占用自己的位置。yield告诉当前正在执行的线程把运行机会交给线程池中拥有相同优先级的线程。yield不能保证使得当前正在运行的线程迅速转换到可运行的状态，它仅能使一个线程从运行状态转到可运行状态，而不是等待或阻塞状态。
9. 线程实例的join()方法可以使得一个线程在另一个线程结束后再执行。如果join()方法在一个线程实例上调用，当前运行着的线程将阻塞直到这个线程实例完成了执行。

# 类加载过程
## 加载
由类加载器完成，做的事情有3个：
1. 根据权限定名获取此类的二进制字节流；
2. 将这个字节流代表的静态存储结构转化为方法区的运行时数据结构；
3. 在内存中生成一个代表这个类的Class对象，作为方法区这个类的各种数据的访问入口。
## 验证
检查待加载的class文件的正确性，目的是为了确保class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。格式检查（是否是class文件、） 元数据检查（是否继承了final的类，是否实现了接口中的所有方法） 符号引用验证（访问性 private protected）
## 准备
在方法区内为类中的静态变量分配存储空间。
准备阶段是正式为类变量(被static修饰的变量)分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中分配。
## 解析
将虚拟机常量池中的符号引用替换为直接引用的过程。

符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时可以无歧义地定位到目标即可。符号引用和虚拟机实现的内存布局无关。
直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用和虚拟机实现的内存布局有关。
## 初始化
如果该类具有超类，则对其初始化，执行静态初始化变量和静态初始化代码块。

# 类加载的分类
1. 隐式加载指的是程序使用new关键字创建对象，则会隐式地调用类的加载器把对应的类加载到JVM中。
2. 显示加载指的是直接通过使用class.forName()方法来把所需的类加载到JVM中。

# 类加载器
在Java语言中，类的加载是动态的，不会一次性加载全部加载再运行，而是先把保证程序运行的基础类（如基类）完全加载到JVM中，其他类则是在需要时加载。从Java虚拟机的角度看，只存在两种不同的类加载器：
1. 启动类加载器，C++语言实现，是虚拟机自身的一部分；
2. 所有的其他的类加载器，Java语言实现，独立于虚拟机外部，并且全部都继承自抽象类java.lang.ClassLoader.
从Java开发人员的角度来看，类加载器可以划分为启动类加载器、扩展类加载器和应用程序类加载器。
1. 启动类加载器(Bootstrap ClassLoader)：这个类主要负责将存放在\<JAVA_HOME\>\lib目录中的，或者被-Xbootclasspath参数所指定的路径中，并且可以被虚拟机识别的(如rt.jar)类库加载到虚拟机内存中。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。
2. 标准扩展(Extension)类加载器：是由Sun的ExtClassLoader (sun.misc.Launcher $ExtClassLoader)实现的，它负责将\<JAVA_HOME\>\lib\ext或者由系统变量java.ext.dirs指定位置中的类库加载到内存中，开发者可以直接使用标准扩展类加载器。
3. 应用程序类加载器(Application ClassLoader)：这个类加载器由sun.misc.Launcher $ApplicationClassLoader实现。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也被称作是系统类加载器。它负责加载用户类路径(ClassPath)上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

# 自定义类加载器
## 自定义的好处
1. 加密：.class文件可以轻易的被反编译，如果你需要把自己的代码进行加密以防止反编译，可以先将编译后的代码用某种加密算法加密，类加密后就不能再用Java的ClassLoader去加载类了，这时就需要自定义ClassLoader在加载类的时候先解密类，然后再加载
2. 从非标准的来源加载代码：如果你的.class文件是放在数据库、甚至是在云端，就可以自定义类加载器，从指定的来源加载类。
## 自定义的实现方式
继承ClassLoader，并覆盖findClass方法。defineClass方法可以把二进制流字节组成的文件转换为一个java.lang.Class（只要二进制字节流的内容符合Class文件规范）。


# 双亲委派模型
双亲委派模型的工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是会把这个加载的请求委派给父类加载器去完成，每一个层次的类加载器都是这么做，只有当父类加载器无法完成类的加载工作时，子类加载器才会尝试自己去加载这个类。

使用双亲委派模型来组织类加载器之间的关系的一个好处是就是Java类随着它的加载器一起具备了一种带有优先级的层次关系，保证了java程序的稳定性。

# JVM 
## Java运行时数据区域
### 程序计数器
当前线程所执行的字节码的行号指示器。Pc(Program Counter Register)，正在执行的指令，当正在执行的是native方法是计数器为空。
### Java虚拟机栈
存放基本数据类型和引用变量。为执行java方法服务，描述的是Java方法执行的内存模型。

栈内存的管理是通过压栈和弹栈来实现的，以栈帧(每个方法开始运行时都会创建一个栈帧，栈帧是用于存储局部变量表、操作数栈、动态链接、方法出口等信息)为单位来进行管理方法之间的调用关系，当有方法调用时，会通过压栈方式进行创建新的栈帧，当方法调用结束时会通过弹栈的操作释放栈帧。
### 本地方法栈   
为虚拟机使用到的native本地方法服务。
### Java堆
几乎所有的对象实例以及数组都在堆上分配。线程之间共享堆内存，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例。

Java堆是垃圾收集器管理的主要区域，因此很多时候也被称为是”GC”堆。从内存分配的角度看，线程共享的Java堆可能划分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer,TLAB)。从内存回收的角度来看，由于现在收集器基本都采用分代收集，所以Java堆还可以细分为：新生代和老年代；再细致一点新生代可以分为Eden空间、From Survivor空间、To Survivor空间等。不过无论如何划分，都与存放的内容无关，无论哪个区域，存放的都仍然是对象实例。

在实现时，堆可以实现成固定大小的，也可以实现成可以扩展的(当前主流虚拟机中都是按照可扩展实现的)。Java堆在物理上不要求存储在连续的内存空间中。
### 方法区
线程共享，用于存储已被虚拟机加载的类信息、常量、静态变量等。有时方法区也被称作永久代(但是本质上两者并不等价，仅仅因为是HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已)，Java虚拟机规范对方法区的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。方法区的内存回收目标主要是针对常量池的回收和对类型的卸载。

运行时常量池是方法区的一部分，用于存放编译期生成的各种字面量和符号引用，这些内容在类加载后进入方法区的运行时常量池中存放。当然并非class文件常量池中的内容才能进入运行时常量池，在运行期间也可将新的常量放入运行时常量池中，如String的intern方法。

## 运行异常
### StackOverflowError
虚拟机栈、本地方法栈在线程请求的栈深度大于虚拟机所允许的深度时抛出该错误。
### OutOfMemory
虚拟机栈、本地方法栈、Java堆在动态扩展的时候没有申请到足够的内存会抛出该异常。

## GC
### 堆内存的分配
1. 新生代：进一步划分为Eden空间、From Survivor空间、To Survivor空间
2. 老年代

### 垃圾回收算法
1. 标记清除：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。
2. 复制：可用的内存按容量大小分为两块大小相等的两块，每次只使用其中的一块。当某一块的内存使用完了，就把还存活的对象移到另一块内存上，然后把当前这块做清理掉。
3. 标记整理：标记过程与”标记-清除算法“一样，但是后续步骤不是直接对可回收的对象进行清理，而是把所有存活的对象都移到一端，然后直接清理掉端边界以外的内存。
4. 分代收集：根据对象存活周期的不同将内存划分为几块。一般是把堆分为新生代和老年代，在新生代采用复制算法回收内存，老年代采用标记-整理或标记-清除算法。算法在运行的过程中优先收集处于新生代的对象，如果一个对象经过多次收集还存活，那么就可以把这个对象移到高一级的堆里，减少对其扫描的次数。

### GC分类
1. Minor GC：从年轻代空间（包括 Eden 和 Survivor 区域）回收内存。当新生代无法为新生对象分配内存空间的时候，会触发Minor GC。因为新生代中大多数对象的生命周期都很短，所以发生Minor GC的频率很高，虽然它会触发stop-the-world，但是它的回收速度很快。
2. Major GC清理Tenured区，用于回收老年代，出现Major GC通常会出现至少一次Minor GC。
3. Full GC是针对整个新生代、老生代、元空间（metaspace，java8以上版本取代perm gen）的全局范围的GC。Full GC不等于Major GC，也不等于Minor GC+Major GC，发生Full GC需要看使用了什么垃圾收集器组合，才能解释是什么样的垃圾回收。

### 触发Full GC的原因
1. 当年轻代晋升到⽼年代的对象⼤⼩，并⽐⽬前⽼年代剩余的空间⼤⼩还要⼤时，会触发Full GC；
2. 当⽼年代的空间使⽤率超过某阈值时，会触发Full GC；
3. 当元空间不⾜时（JDK1.7永久代不足），也会触发Full GC；
4. 当调⽤System.gc()也会安排⼀次Full GC。

### 可达性分析
用于在GC时判断对象是否存活，主要有两种方法。
#### 引用计数法
每个对象都有一个引用计数器，每当该对象被引用时则计数器加1，当某个引用失效时，则引用计数器减1。任何时刻引用计数器的值为0的对象就是不可能再被引用的。

缺点是无法解决循环引用的问题，现在主流的java虚拟机没有采用引用计数法来管理内存。

#### 可达性分析算法
通过一系列称为”GC Roots“的对象作为起始点，从这些节点开始向下搜索与其相连的对象，搜索过程中经过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链时，则证明该对象是不可用的。

在主流的商用程序语言(Java C#)的主流实现中，都是通过可达性分析算法来判定对象是否存活的。

在可达性分析算法中不可达的对象，也并非是”非死不可的“，要真正宣告一个对象是否死亡，需要经历两次被标记过程。第一次标记判断是否有必要执行finalize()方法，将有必要执行的对象放到F-Queue的队列之中；稍后GC会对F-Queue进行第二次标记，finalize()方法是对象逃脱死亡命运的最后一次机会，如果对象在finalize()方法中成功地与引用链上的任何一个对象相关联，那么在第二次标记时会把这个对象彻底移除”即将回收“的集合。

finalize()方法是Object类的一个方法，在垃圾回收器执行时会调用被回收对象的finalize()方法，可以覆盖此方法来实现对其他资源的回收，比如关闭文件等。需要注意的是，一旦垃圾回收器准备好释放对象占用的空间时，将首先调用其finalize()方法，并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。

### GC Roots
在Java语言中，可作为GC Roots的对象主要包括以下四个方面。
1. 虚拟机栈中的引用对象；
2. 本地方法栈中本地方法引用的对象；
3. 方法区中类静态属性引用的对象；
4. 方法区内常量引用的对象。

### GC停顿
因为可达性分析工作必须在一个能确保一致性的快照中进行，这里的“一致性”的意思是指在整个分析期间整个执行系统看起来就像被冻结在某个时间点上，不可以出现分析过程中对象引用关系还在不断变化的情况。不然的话可达性分析的结果就无法得到保证，这是导致GC进行时必须停顿所有Java执行线程的一个重要原因。

### 垃圾回收器
#### Serial收集器
一个单线程的收集器，但它“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作。更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程。新生代收集器、采用复制算法。

优点：与其他收集器的单线程比，简单而高效。

Serial收集器对于运行在Client模式下的虚拟机来说是一个很好的选择。
#### ParNew收集器
其实就是Serival收集器的多线程版本。新生代收集器、采用复制算法。	适用于运行在server模式下的虚拟机中首选的新生代收集器。
#### Parallel Scavenge收集器
新生代收集器、采用复制算法、并行的多线程收集。主要适合在后台运算而不需要太多交互的任务，注重的是吞吐量。

如果用户对于收集器运作不是很了解，手工优化困难的时候，使用Parallel Scavenge收集器配合自适应调节策略，把内存管理的调节任务交给虚拟机去完成将是一个不错的选择。

自适应调节策略也是Parallel Scavenge收集器与ParNew收集器的一个不同。
#### SerialOld收集器
是Serial的老年代版本，同样是一个单线程收集器，使用“标记-整理”算法。主要给在Client模式下的虚拟机使用。如果是在Server模式下则主要有两大用途，一是在JDK1.5以及之前的版本中与Parallel Scavenge 收集器搭配使用，另一种用途就是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。
#### Parallel Old收集器
是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge收集器和Parallel Old收集器。
#### CMS(Conourrent Mark Sweep )收集器
以获取最短回收停顿时间为目标的收集器。基于”标记-清除”算法实现。

整个过程分为四步：初始标记、并发标记、重新标记、并发清除。

优点：并发收集、低停顿。

缺点：对CPU资源敏感；无法处理浮动垃圾；收集结束会有大量碎片。
#### G1收集器
面向服务端应用的垃圾收集器，标记整理。与其他GC收集器相比：G1具有如下特点：并发与并行；分代收集；空间整合；可预测的停顿。

运作的过程大致分为四个步骤：初始标记；并发标记；最终标记；筛选回收。

备注：并发(Parallel):指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态；
并行(Concurrent):指用户线程与垃圾收集线程同时执行(但不一定是并行的，可能会交替执行 )，用户程序在继续运行，而垃圾收集程序运行于另一个CPU上。


## 内存泄漏和内存溢出
### 内存泄漏
内存泄露是指一个不再被程序使用的对象或变量还在内存中占用空间。在java语言中，判断一个内存空间是否符合垃圾回收的标准有两个：
1. 给对象赋予了空值null，以后再也没有不会被使用；
2. 给对象赋予了新值，重新分配了内存空间。

一般来说，内存泄露主要有两种情况：
1. 在堆中申请的空间没有被释放；
2. 对象已不再使用但是还仍然在内存中保留着。

垃圾回收机制的引入可以有效地解决第一种情况，但是对第二种情况却没有办法解决，因此java语言中内存泄露主要指的是第二种情况。

在Java中，内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点，首先，这些对象是可达的，即在有向图中，存在通路可以与其相连；其次，这些对象是无用的，即程序以后不会再使用这些对象。如果对象满足这两个条件，这些对象就可以判定为Java中的内存泄漏，这些对象不会被GC所回收，然而它却占用内存。

在Java语言中，容易引起内存泄露的原因有很多，主要可以分为以下几种。
1. 静态集合类。例如HashMap和Vector，如果这些容器是静态的，那么它们的声明周期与程序一样，在程序结束之前这些容器所占的空间将得不到释放，从而造成内存泄露；
2. 各种连接。比如Connection、Statement、ResultSet等如果使用之后不显示地关闭，会造成大量的对象无法回收，造成内存泄露；
3. 监听器。在java中，往往一个程序使用多个监听器，但是在释放对象的时候却没有删除相应的监听器对象就会导致内存泄露；
4. 变量不合理的作用域。如果一个变量定义的作用范围大于其使用范围 ，就有可能造成内存泄露，另一个方面如果没有及时地把一个对象设置为null，也有可能导致内存泄露；
5. 单例模式可能会造成内存泄露。如果以静态的方式存储单例对象的话，那么它在JVM的整个生命周期中都存在，就会导致内存泄露。

### 内存溢出
内存溢出是指程序要求的内存，超出了系统所能分配的范围，从而发生溢出。

## JVM调优
### 常用JVM命令行工具
#### jps
只运行jps输出的是当前运行的java进程(Java程序的进程ID，Main函数)；   
运行jps –q只输出进程ID，而不输出类的名称；   
jps –m输出传递给Java进程(主函数)的短名称；   
jps –l输出主函数的完整路径；   
jps –v输出传递给JVM的参数。
#### jstat
虚拟机统计信息监视工具；可以用于观察Java应用程序运行时信息的工具。

jstat可以实时显示本地或远程JVM进程中类装载、内存、垃圾收集、JIT编译等数据（如果要显示远程JVM信息，需要远程主机开启RMI支持）。如果在服务启动时没有指定启动参数-verbose:gc，则可以用jstat实时查看gc情况。

在没有GUI图形界面，只提供了纯文本控制台环境的服务器上，jstat是运行期定位虚拟性能问题的首选工具。

如jstat –gc 2764 250 20表示查询进程2764垃圾收集状况，每250ms查询一次，一共查询20次。后面两个参数省略时表示只查询一次。

命令格式为jstat option vmid interval count.

其中option主要分为3类：类装载、垃圾收集、运行期编译。

#### jinfo
Java配置信息工具；用于查询当前运行时的JVM属性和参数的值。
#### jmap
Java内存映像工具；用于显示当前Java堆和永久代的详细信息（如当前使用的收集器，当前的空间使用率等）。

jmap –heap:显示java堆的相信信息，如使用哪种收集器、参数配置、分代状态等。

jmap -dump:生成java堆转储快照。

#### jhat
虚拟机堆转储快照分析工具；用于分析使用jmap生成的dump文件，是JDK自带的工具，使用方法为： jhat -J -Xmx512m [file]

#### jstack
Java堆栈跟踪工具

用于生成当前JVM的所有线程快照，线程快照是虚拟机每一条线程正在执行的方法,目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的原因。线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做些什么事情或者是在等待什么资源。
 
### JDK可视化工具
#### JConsole
JConsole工具是JDK自带的图形化性能监控工具。通过JConsole工具，可以查看Java应用程序的运行概况，监控堆信息、永久区使用情况、类加载情况。

在JConsole中可以查看堆的详细信息，包括堆的大小、使用率、eden区大小、survivor区大小、永久区大小。

JConsole可以方便地查看系统内的线程信息，并且可以快速定位死锁问题。

JConsole的类页面可以显示系统已经装载的类数量。

JConsole的VM摘要显示了当前Java应用程序的基本信息，如虚拟机类型、虚拟机版本、系统线程信息、操作系统内存信息、堆信息、垃圾回收器信息以及路径信息等。

### JVM调优一般步骤
1. 监控GC的状态
使用各种JVM工具，查看当前日志，分析当前JVM参数设置，并且分析当前堆内存快照和gc日志，根据实际的各区域内存划分和GC执行时间，觉得是否进行优化；
2. 分析结果，判断虚拟机的配置参数是否需要优化   
如果各项参数设置合理，系统没有超时日志出现，GC频率不高，GC耗时不高，那么没有必要进行GC优化；如果GC时间超过1-3秒，或者频繁GC，则必须优化；   
注：如果满足下面的指标，则一般不需要进行GC：   
Minor GC执行时间不到50ms；   
Minor GC执行不频繁，约10秒一次；   
Full GC执行时间不到1s；   
Full GC执行频率不算频繁，不低于10分钟1次；
3. 调整GC类型和内存分配   
如果内存分配过大或过小，或者采用的GC收集器比较慢，则应该优先调整这些参数，并且先找1台或几台机器进行beta，然后比较优化过的机器和没有优化的机器的性能对比，并有针对性的做出最后选择；
4. 不断的分析和调整   
通过不断的试验和试错，分析并找到最合适的参数
5. 全面应用参数   
如果找到了最合适的参数，则将这些参数应用到所有服务器，并进行后续跟踪。
