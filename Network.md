# 页面请求流程
1. 用户在浏览器输入链接地址请求所需资源。
2. 域名解析 浏览器DNS缓存->操作系统DNS缓存->DNS系统调用，向首选DNS服务器发起域名解析请求
2. 浏览器将请求组装成指定格式发送给服务端，客户端与服务器端之间通过HTTP来完成具体的交互。其中请求的数据流中主要包含HTTP(HyperText Transfer Protocol,超文本传输协议，建立在TCP/IP基础上的一个协议，主要用来实现客户端与服务器端之间的通信)请求方法（GET或POST）、请求网址（URL、Uniform Resource Locator,统一资源定位符）以及请求的一些参数信息。
3. 服务器接收到客户端发来的请求，并查找用户所需要的资源。
4. 服务器查找到用户请求的资源后，把该资源返回给客户端。
5. 服务器通过把响应消息组装成特定的消息格式后返回给客户端，这个过程通过HTTP来完成。响应的数据流主要包含状态编码（代表请求成功或失败），Content-type(例如text、picture、HTML等)，响应消息的内容（图片或HTML格式的内容）。
6. 浏览器对HTML进行解析，并把响应结果展现给用户。

# DNS解析过程
1. 主机向本地域名服务器的查询一般都是采用递归查询。所谓递归查询就是：如果主机所询问的本地域名服务器不知道被查询的域名的 IP 地址，那么本地域名服务器就以 DNS 客户的身份，向根域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让主机自己进行下一步查询。因此，递归查询返回的查询结果或者是所要查询的 IP 地址，或者是报错，表示无法查询到所需的 IP 地址。

2. 本地域名服务器向根域名服务器的查询的迭代查询。迭代查询的特点：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地服务器进行后续的查询。根域名服务器通常是把自己知道的顶级域名服务器的 IP 地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的 IP 地址，要么告诉本地服务器下一步应当向哪一个权限域名服务器进行查询。最后，本地域名服务器得到了所要解析的 IP 地址或报错，然后把这个结果返回给发起查询的主机。

# DNS域名缓存
在域名服务器中广泛使用了高速缓存，用来存放最近查询过的域名以及从何处获得域名映射信息的记录。

由于名字到地址的绑定并不经常改变，为保持高速缓存中的内容正确，域名服务器应为每项内容设置计时器并处理超过合理时间的项（例如：每个项目两天）。当域名服务器已从缓存中删去某项信息后又被请求查询该项信息，就必须重新到授权管理该项的域名服务器绑定信息。当权限服务器回答一个查询请求时，在响应中都指明绑定有效存在的时间值。

# GET请求与POST请求
1. GET请求的数据会附在URL之后，以?分割URL和传输数据，参数之间以&相连，POST把提交的数据则放置在是HTTP包的包体中。
2. GET的长度受限于url的长度，而url的长度限制是特定的浏览器和服务器设置的，理论上GET的长度可以无限长。
3. POST是没有大小限制的，HTTP协议规范也没有进行大小限制，起限制作用的是服务器的处理程序的处理能力
4. 幂等性：幂等的HTTP方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。在正确实现的条件下，GET，HEAD，PUT和DELETE等方法都是幂等的，而POST方法不是。

# OSI七层模型
1. 应用层：最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：HTTP，HTTPS，FTP，POP3、SMTP等。
2. 表示层：表示层提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。
3. 会话层：会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。
4. 传输层：传输层建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，TCP UDP就是在这一层。端口号既是这里的“端”。
5. 网络层：本层通过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的IP层。这一层就是我们经常说的IP协议层。IP协议是Internet的基础。
6. 数据链路层：将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。
7. 物理层：实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。

# TCP五层模型
1. 应用层:决定了向用户提供应用服务时通信的活动，定义进程间的通信活动。例如FTP和DNS。HTTP也在这层。
2. 传输层:提供了处于网络连接中的两台计算机之间的数据传输。TCP和UDP
3. 网络层:用来处理网络上流动的数据包。IP、TCMP、ARP。
4. 数据链路层:用来处理连接网络的硬件部分。
5. 物理层：负责光电信号传递方式。集线器工作在物理层。

# TCP三次握手
1. 第一次握手：建立连接时，客户端发送syn包（seq=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。
2. 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（seq=k），即SYN+ACK包，此时服务器进入SYN_RECV状态。
3. 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。

# 两次握手行不行？
两次握手下，服务端只知道客户端可以发送数据，不知道客户端是否能接受数据，这使得传输本身变得不可靠。另外，若网络存在拥堵，触发超时重传，并成功在两次握手下建立连接，而此后如果之前堵塞请求到达了服务器，服务器会再次应答同意连接，并等待发送数据，而客户端是认为这次请求是失效的，不会向服务端发送数据，导致服务端一直耗时等待，造成资源浪费。所以需要第三次握手来确认连接的建立，来确认客户端确实会向服务端发送数据。

# 四次挥手
客户端发送FIN包请求结束连接；服务端发送ACK确认收到FIN包，服务端完成关闭连接的准备后，发送FIN包告诉客户端已经准备好释放连接；客户端发送ACK包告知收到FIN包；服务端收到ACK包后进入CLOSED状态，而客户端为了确保服务端成功接收到ACK，需要等待2MSL时间，如果服务端没能成功接受ACK，会在这个时间里向客户端重传FIN包；在等待2MSL时间后，客户端关闭连接。

# MSL 
MSL: Maximum Segment Lifetime.一段TCP报文在传输过程中的最大生命周期。

# 为什么要等待2MSL时间？
用于确认服务端已经成功接收到ACK包，从而关闭连接。如果服务端没收到，会在2MSL时间内重新发送FIN包，客户端此时可以重传ACK，来确保双端都可以关闭连接。

# TCP可靠传输原理
## 校验和
每个发送的数据段都会进行校验和的比对，如果校验和不一致，数据传输一定有误。
## 确认应答和序列号
TCP传输时将每个字节的数据都进行了编号，这就是序列号。每次接收方收到数据后，都会对传输方进行确认应答。也就是发送ACK报文。这个ACK报文当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发。
## 超时重传
如果发送方发送完数据后，迟迟没有等到接收方的ACK报文，发送方会对刚才发送的数据进行重新发送。
## 连接管理
即三次握手和四次挥手。
## 流量控制
为了防止发送端发送速度过快溢出接收端的缓冲区，会在报头中设置滑动窗口大小，这个大小实际上就是接收端的缓冲区剩余大小。发送端依此来进行流量控制。
## 拥塞控制
在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏，这种情况就叫做**网络拥塞**。为了防止网络出现拥堵，导致丢包，TCP引入了一些机制来进行拥塞控制。
发送方维护一个叫做**拥塞窗口cwnd**的状态变量，其值取决于网络的拥塞程度，动态变化。
* 维护原则：只要网络没有出现拥塞，拥塞窗口就再增大一些；只要网络出现拥塞，拥塞窗口就减少一些。
* 为了防止拥塞窗口cwnd的增长引起网络阻塞，还需要另外一个变量：**慢开始门限ssthresh。i.当cwnd < ssthresh时，使用慢启动算法；ii.当cwnd >ssthresh时，停止使用慢启动算法，改用拥塞避免算法；
* 判断网络拥塞依据：没有按时收到应达的ack报文，触发重传。
* 发送方将拥塞窗口作为发送窗口，即**swnd = cwnd**
* 慢开始：在开始发送数据时，先发送少量的数据探路。先把拥塞窗口cwnd设置为一个最大报文段MSS的数值。而在每收到一个新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。用这样的方法逐步增大发送方的拥塞窗口cwnd，可以使分组注入到网络的速率更加合理。此时拥塞窗口的大小是**指数增长**的。
* 拥塞避免：当cwnd >ssthresh时，停止使用慢启动算法，改用拥塞避免算法。即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍，这样拥塞窗口cwnd按线性规律缓慢的增长，比慢开始算法的拥塞窗口增长速率缓慢的多。
* 乘法减小：无论在慢启动阶段还是在拥塞控制阶段，只要网络出现超时，就是将cwnd置为1，sthresh置为cwnd的一半，然后开始执行慢启动算法。
* 加法增大：当网络频发出现超时情况时，ssthresh就下降的很快，为了减少注入到网络当中的分组数，而加法增大是执行拥塞避免算法后，是拥塞窗口缓慢的增大，以防止网络过早出现拥塞。
* 快重传：  快重传算法要求首先接收方收到一个失序的报文段后立刻发出重复确认，而不要等待自己发送数据时才进行捎带确认。
* 快恢复：当发送方连续收到三个重复确认时，执行“乘法减小”算法，慢启动门限减半，为了预防网络发生阻塞。由于发送方现在认为网络很可能没有发生阻塞，因此现在不执行慢启动算法，而是把cwnd值设置为慢启动门限减半后的值，然后开始执行拥塞避免算法，拥塞窗口cwnd值线性增大。

# KeepAliveTimer
KeepAliveTimer在应用进程选取了Socket的SO_KEEPALIVE选项时生效。如果连接的连续空闲时间超过2小时，保活定时器超时，向对端发送连接探测报文段，强迫对端响应。如果收到了期待的响应， TCP可确定对端主机工作正常，在该连接再次空闲超过2小时之前，TCP不会再进行保活测试。如果收到的是其他响应，TCP可确定对端主机已重启。如果连续若干次保活测试都未收到响应，TCP就假定对端主机已崩溃，尽管它无法区分是主机故障(例如，系统崩溃而尚未重启)，还是连接故障(例如，中间的路由器发生故障或电话线断了)。

# DDos攻击
一个TCP连接的建立过程：
1. 客户端向服务端发送连接请求数据包；
2. 服务端向客户端回复连接请求数据包，然后服务器等待客户端发送tcp/ip连接的第三步数据包；
3. 如果客户端不向服务端发送最后一个数据包，则服务器必须等待30s到2min的时间才能将连接关闭。   
**当大量的请求只进行到第二步的时候，而不进行第三步，服务器大量的资源都变成了等待第三个数据包，则造成DDos攻击。**

# 拆包粘包 [来源](https://www.cnblogs.com/panchanggui/p/9518735.html)  
粘包拆包问题是处于网络比较底层的问题，在数据链路层、网络层以及传输层都有可能发生。我们日常的网络应用开发大都在传输层进行，由于UDP有消息保护边界，不会发生粘包拆包问题，因此粘包拆包问题只发生在TCP协议中。

如果客户端连续不断的向服务端发送数据包时，服务端接收的数据会出现两个数据包粘在一起的情况。

1. TCP 是基于字节流的，虽然应用层和 TCP 传输层之间的数据交互是大小不等的数据块，但是 TCP 把这些数据块仅仅看成一连串无结构的字节流，没有边界；

2. 从 TCP 的帧结构也可以看出，在 TCP 的首部没有表示数据长度的字段。

基于上面两点，在使用 TCP 传输数据时，才有粘包或者拆包现象发生的可能。一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。

假设客户端向服务端连续发送了两个数据包，用packet1和packet2来表示，那么服务端收到的数据可以分为三种，现列举如下：
1. 接收端正常收到两个数据包，即没有发生拆包和粘包的现象。
2. 接收端只收到一个数据包，由于TCP是不会出现丢包的，所以这一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。这种情况由于接收端不知道这两个数据包的界限，所以对于接收端来说很难处理。
3. 接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包。这两种情况如果不加特殊处理，对于接收端同样是不好处理的。
## 原因
1. 应用程序写入的数据大于套接字缓冲区大小，这将会发生拆包。
2. 应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包。
3. 进行MSS（最大报文长度）大小的TCP分段，当TCP报文长度-TCP头部长度>MSS的时候将发生拆包
4. 接收方法不及时读取套接字缓冲区数据，这将发生粘包。
## 解决办法
1. 发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。
2. 发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。
3. 可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。   


# UDP
1. UDP是无连接
2. UDP使用尽最大努力交付，即不保证可靠性
3. UDP是面向报文的
4. UDP 没有拥塞控制，所以即使网络出现拥塞，也不会使源主机的发送速率降低。
5. UDP 支持一对一、一对多、多对一、多对多的交互通信。
6. UDP的首部开销小，只有8个字节，比TCP20个字节要短。
使用没有拥塞控制功能的UDP有可能会引起更严重的拥塞问题。有时候需要保证UDP的可靠性，应用进程可以在不影响应用的前提下，增加一些可靠性措施，如采用前向纠错或重传已丢失的报文。可以在应用层实现。

## TCP和UDP分别对应的常见应用层协议
### TCP 对应的应用层协议

FTP：定义了文件传输协议，使用 21 端口。常说某某计算机开了 FTP 服务便是启动了文件传输服务。下载文件，上传主页，都要用到 FTP 服务。

Telnet：它是一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于 DOS 模式下的通信服务。如以前的 BBS 是-纯字符界面的，支持 BBS 的服务器将 23 端口打开，对外提供服务。

SMTP：定义了简单邮件传送协议，现在很多邮件服务器都用的是这个协议，用于发送邮件。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置-中常看到有这么 SMTP 端口设置这个栏，服务器开放的是 25 号端口。

POP3：它是和 SMTP 对应，POP3 用于接收邮件。通常情况下，POP3 协议所用的是 110 端口。也是说，只要你有相应的使用 POP3 协议的程序（例如 Fox-mail 或 Outlook），就可以不以 Web 方式登陆进邮箱界面，直接用邮件程序就可以收到邮件（如是163 邮箱就没有必要先进入网易网站，再进入自己的邮箱来收信）。

HTTP：从 Web 服务器传输超文本到本地浏览器的传送协议。

### UDP 对应的应用层协议

DNS：用于域名解析服务，将域名地址转换为 IP 地址。DNS 用的是 53 号端口。

SNMP：简单网络管理协议，使用 161 号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。

TFTP(Trival File Transfer Protocal)：简单文件传输协议，该协议在熟知端口 69 上使用 UDP 服务。

# ARP协议
地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到局域网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。

每台主机都会在自己的 ARP 缓冲区中建立一个 ARP 列表，以表示 IP 地址和 MAC 地址的对应关系。当源主机需要将一个数据包要发送到目的主机时，会首先检查自己 ARP 列表中是否存在该 IP 地址对应的 MAC 地址：如果有，就直接将数据包发送到这个 MAC 地址；如果没有，就向本地网段发起一个 ARP 请求的广播包，查询此目的主机对应的 MAC 地址。

此 ARP 请求数据包里包括源主机的 IP 地址、硬件地址、以及目的主机的 IP 地址。网络中所有的主机收到这个 ARP 请求后，会检查数据包中的目的 IP 是否和自己的 IP 地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的 MAC 地址和 IP 地址添加到自己的 ARP 列表中，如果 ARP 表中已经存在该 IP 的信息，则将其覆盖，然后给源主机发送一个 ARP 响应数据包，告诉对方自己是它需要查找的 MAC 地址；源主机收到这个 ARP 响应数据包后，将得到的目的主机的 IP 地址和 MAC 地址添加到自己的 ARP 列表中，并利用此信息开始数据的传输。如果源主机一直没有收到 ARP 响应数据包，表示 ARP 查询失败。

# IP地址分类
 IP 地址是指互联网协议地址，是 IP 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。IP 地址编址方案将 IP 地址空间划分为 A、B、C、D、E 五类，其中 A、B、C 是基本类，D、E 类作为多播和保留使用，为特殊地址。

每个 IP 地址包括两个标识码（ID），即网络 ID 和主机 ID。同一个物理网络上的所有主机都使用同一个网络 ID，网络上的一个主机（包括网络上工作站，服务器和路由器等）有一个主机 ID 与其对应。A~E 类地址的特点如下：

* A类地址：以 0 开头，第一个字节范围：0~127；

* B类地址：以 10 开头，第一个字节范围：128~191；

* C类地址：以 110 开头，第一个字节范围：192~223；

* D类地址：以 1110 开头，第一个字节范围为 224~239；

* E类地址：以 1111 开头，保留地址。

# 停止等待协议
停止等待协议是最简单但也是最基础的数据链路层协议。它是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组；在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。主要包括以下几种情况：无差错情况、出现差错情况（超时重传）、确认丢失和确认迟到、确认丢失和确认迟到。

# ARQ 协议（Automatic Repeat-reQuest，ARQ）
自动重传请求（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层的错误纠正协议之一。它包括停止等待ARQ协议和连续ARQ协议，错误侦测（Error Detection）、正面确认（Positive Acknowledgment）、逾时重传（Retransmission after Timeout）与负面确认继以重传（Negative Acknowledgment and Retransmission）等机制。

# 停止等待ARQ协议
停止等待ARQ是以停止等待协议（stop-and-wait）为思想的，停止等待协议是最简单但也是最基础的数据链路层协议。

众所周知信道是不可靠的，而停止等待协议是保证传输可靠性的重要途径。该协议的内容也很简单，就是一次只发送一个分组的消息，等对方确认之后再继续发后面的，如果没有接收到确认会触发超时重传，这样可以保证对方可以收到完整的消息。

停止等待ARQ协议也可以看做是一比特滑动窗口协议，发送窗口与接收窗口都等 1 。

缺点：通信信道的利用率很低，传输时延大。

## 连续ARQ协议
连续ARQ（Automatic Repeat reQuest）协议也是结合滑动窗口协议的，其在发送方维持着一个一定大小的发送窗口，位于发送窗口内的所有分组都可连续发送出去，而中途不需要等待对方的确认。这样信道的利用率就提高了。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。

## 回退N帧ARQ(GO-BACK-N)
回退n帧ARQ可以看做是发送窗口 > 1 ，接收窗口 = 1的滑动窗口协议，这就是说接收方不必对收到的分组逐个发送确认，而是在收到几个分组后，对按序到达的最后一个分组发送确认，这就表示：到这个分组为止的所有分组都已正确收到了。

但网络状况不好的时候会出现，如发送窗口为 10 时，一次发送 10 个数据包，前面两个正确返回了，但第三个丢失了，这时发送方就得重新从第三个包开始，把后面的再传一遍，接收方也必须抛弃前面的 4 - 10 这几个帧，所以网络不佳的情况下可能会比停止等待ARQ还慢。

## 选择ARQ(SELECTIVE-REPEAT)
发信侧不用等待收信侧的应答，持续的发送多个帧，假如发现已发送的帧中有错误发生，那么发信侧将只重新发送那个发生错误的帧。
特点：相对于GBN 复杂度高，但是不需要发送没必要的帧，所以效率高。
例：如果序列号有K bits，那么这个ARQ的协议大小为：2^(k-1)。

# HTTP状态码
## 1XX 信息
1. 100 Continue ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。

## 2XX 成功
1. 200 OK
2. 204 No Content ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。
3. 206 Partial Content ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。

## 3XX 重定向
1. 301 Moved Permanently ：永久性重定向；
2. 302 Found ：临时性重定向；
3. 303 See Other ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。
4. 304 Not Modified ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。
5. 307 Temporary Redirect ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。

## 4XX 客户端错误
1. 400 Bad Request ：请求报文中存在语法错误。
2. 401 Unauthorized ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。
3. 403 Forbidden ：请求被拒绝。
4. 404 Not Found

## 5XX 服务器错误
1. 500 Internal Server Error ：服务器正在执行请求时发生错误；
2. 503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。

# HTTP长连接
在 HTTP/1.0 中默认使用短连接。也就是说，客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个 HTML 或其他类型的 Web 页中包含有其他的 Web 资源（如：JavaScript 文件、图像文件、CSS 文件等），每遇到这样一个 Web 资源，浏览器就会重新建立一个 HTTP 会话。

而从 HTTP/1.1 起，默认使用长连接，用以保持连接特性。使用长连接的 HTTP 协议，会在响应头加入这行代码：
```yaml
Connection: keep-alive
```
在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。

# HTTP版本变化
## HTTP 1.1
1. 增加长连接
2. 支持只发送 header 而不发送 body。原因是先用 header 判断能否成功，再发数据，节约带宽。
## HTTP 2.0
1. HTTP2.0 支持多路复用，同一个连接可以并发处理多个请求，方法是把 HTTP数据包拆为多个帧，并发有序的发送，根据序号在另一端进行重组，而不需要一个个 HTTP请求顺序到达；
2. HTTP2.0 支持服务端推送，就是服务端在 HTTP 请求到达后，除了返回数据之外，还推送了额外的内容给客户端；
3. HTTP2.0 压缩了请求头，同时基本单位是二进制帧流，这样的数据占用空间更少；
4. HTTP2.0 适用于 HTTPS 场景，因为其在 HTTP和 TCP 中间加了一层 SSL 层。

# HTTPS
## 工作过程
1. 客户端发送自己支持的加密规则给服务器，代表告诉服务器要进行连接了；
2. 服务器从中选出一套加密算法和 hash 算法以及自己的身份信息（地址等）以证书的形式发送给浏览器，证书中包含服务器信息，加密公钥，证书的办法机构；
3. 客户端收到网站的证书之后要做下面的事情： 
* 验证证书的合法性；
* 果验证通过证书，浏览器会生成一串随机数，并用证书中的公钥进行加密；
* 用约定好的 hash 算法计算握手消息，然后用生成的密钥进行加密，然后一起发送给服务器。
4. 服务器接收到客户端传送来的信息，要做下面的事情：
* 用私钥解析出密码，用密码解析握手消息，验证 hash 值是否和浏览器发来的一致；
* 使用密钥加密消息；
5. 如果计算法 hash 值一致，握手成功。

## HTTP和HTTPS的区别
1. 开销：HTTPS 协议需要到 CA 申请证书，一般免费证书很少，需要交费；
2. 资源消耗：HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 ssl 加密传输协议，需要消耗更多的 CPU 和内存资源；
3. 端口不同：HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是  80，后者是 443；
4. 安全性：HTTP 的连接很简单，是无状态的；HTTPS 协议是由 TSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。

## HTTPS优缺点
### 优点
1. 使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；
2. HTTPS 协议是由 SSL + HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 HTTP 协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性；
3. HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。
### 缺点
1. HTTPS 协议握手阶段比较费时，会使页面的加载时间延长近 50%，增加 10% 到 20% 的耗电；
2. HTTPS 连接缓存不如 HTTP 高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；
3. SSL 证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用；
4. SSL 证书通常需要绑定 IP，不能在同一 IP 上绑定多个域名，IPv4 资源不可能支撑这个消耗；
5. HTTPS 协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL 证书的信用链体系并不安全，特别是在某些国家可以控制 CA 根证书的情况下，中间人攻击一样可行。

## 数字签名
为了避免数据在传输过程中被替换，比如黑客修改了你的报文内容，但是你并不知道，所以我们让发送端做一个数字签名，把数据的摘要消息进行一个加密，比如 MD5，得到一个签名，和数据一起发送。然后接收端把数据摘要进行 MD5 加密，如果和签名一样，则说明数据确实是真的。

## 数字证书
非对称加密中，双方使用公钥进行解密。虽然数字签名可以保证数据不被替换，但是数据是由公钥加密的，如果公钥也被替换，则仍然可以伪造数据，因为用户不知道对方提供的公钥其实是假的。所以为了保证发送方的公钥是真的，CA 证书机构会负责颁发一个证书，里面的公钥保证是真的，用户请求服务器时，服务器将证书发给用户，这个证书是经由系统内置证书的备案的。

## 对称加密和非对称加密
对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方。

非对称加密指使用一对非对称密钥，即：公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。

由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性。但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。
